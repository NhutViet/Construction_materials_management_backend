import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { Notification, NotificationDocument, NotificationType, NotificationPriority, NotificationStatus } from '../models/notification.model';
import { CreateNotificationDto, UpdateNotificationDto, NotificationQueryDto } from '../dto/notification.dto';

@Injectable()
export class NotificationService {
  constructor(
    @InjectModel(Notification.name) private notificationModel: Model<NotificationDocument>,
  ) {}

  async create(createNotificationDto: CreateNotificationDto): Promise<Notification> {
    const notification = new this.notificationModel({
      ...createNotificationDto,
      relatedEntityId: createNotificationDto.relatedEntityId ? new Types.ObjectId(createNotificationDto.relatedEntityId) : undefined,
      userId: createNotificationDto.userId ? new Types.ObjectId(createNotificationDto.userId) : undefined,
    });
    return notification.save();
  }

  async findAll(query: NotificationQueryDto): Promise<{ notifications: Notification[]; total: number; page: number; limit: number }> {
    const {
      type,
      priority,
      status,
      userId,
      isAutoGenerated,
      search,
      page = '1',
      limit = '10',
      sortBy = 'createdAt',
      sortOrder = 'desc'
    } = query;

    const filter: any = { isDeleted: false };

    if (type) filter.type = type;
    if (priority) filter.priority = priority;
    if (status) filter.status = status;
    if (userId) filter.userId = new Types.ObjectId(userId);
    if (isAutoGenerated !== undefined) filter.isAutoGenerated = isAutoGenerated;
    if (search) {
      filter.$or = [
        { title: { $regex: search, $options: 'i' } },
        { message: { $regex: search, $options: 'i' } }
      ];
    }

    const sort: any = {};
    sort[sortBy] = sortOrder === 'asc' ? 1 : -1;

    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);
    const skip = (pageNum - 1) * limitNum;

    const [notifications, total] = await Promise.all([
      this.notificationModel
        .find(filter)
        .sort(sort)
        .skip(skip)
        .limit(limitNum)
        .populate('userId', 'username fullname')
        .exec(),
      this.notificationModel.countDocuments(filter)
    ]);

    return {
      notifications,
      total,
      page: pageNum,
      limit: limitNum
    };
  }

  async findOne(id: string): Promise<Notification> {
    const notification = await this.notificationModel
      .findOne({ _id: id, isDeleted: false })
      .populate('userId', 'username fullname')
      .exec();

    if (!notification) {
      throw new NotFoundException('Thông báo không tồn tại');
    }

    return notification;
  }

  // Tìm thông báo kể cả đã bị xóa (để kiểm tra quyền sở hữu)
  async findOneIncludingDeleted(id: string): Promise<Notification | null> {
    return this.notificationModel
      .findOne({ _id: id })
      .populate('userId', 'username fullname')
      .exec();
  }

  // Tìm thông báo kể cả đã bị xóa (không populate để kiểm tra quyền sở hữu)
  async findOneIncludingDeletedForAuth(id: string): Promise<Notification | null> {
    return this.notificationModel
      .findOne({ _id: id })
      .exec();
  }

  async update(id: string, updateNotificationDto: UpdateNotificationDto): Promise<Notification> {
    const updateData: any = { ...updateNotificationDto };
    
    if (updateNotificationDto.relatedEntityId) {
      updateData.relatedEntityId = new Types.ObjectId(updateNotificationDto.relatedEntityId);
    }

    const notification = await this.notificationModel.findOneAndUpdate(
      { _id: id, isDeleted: false },
      updateData,
      { new: true }
    ).populate('userId', 'username fullname');

    if (!notification) {
      throw new NotFoundException('Thông báo không tồn tại');
    }

    return notification;
  }

  async remove(id: string): Promise<void> {
    const notification = await this.notificationModel.findOneAndUpdate(
      { _id: id, isDeleted: false },
      { isDeleted: true }
    );

    if (!notification) {
      throw new NotFoundException('Thông báo không tồn tại');
    }
  }

  async markAsRead(id: string): Promise<Notification> {
    const notification = await this.notificationModel.findOneAndUpdate(
      { _id: id, isDeleted: false },
      { 
        status: NotificationStatus.READ,
        readAt: new Date()
      },
      { new: true }
    ).populate('userId', 'username fullname');

    if (!notification) {
      throw new NotFoundException('Thông báo không tồn tại');
    }

    return notification;
  }

  async markAsUnread(id: string): Promise<Notification> {
    const notification = await this.notificationModel.findOneAndUpdate(
      { _id: id, isDeleted: false },
      { 
        status: NotificationStatus.UNREAD,
        readAt: undefined
      },
      { new: true }
    ).populate('userId', 'username fullname');

    if (!notification) {
      throw new NotFoundException('Thông báo không tồn tại');
    }

    return notification;
  }

  async markAllAsRead(userId?: string): Promise<{ modifiedCount: number }> {
    const filter: any = { 
      isDeleted: false,
      status: NotificationStatus.UNREAD
    };

    if (userId) {
      filter.userId = new Types.ObjectId(userId);
    }

    const result = await this.notificationModel.updateMany(
      filter,
      { 
        status: NotificationStatus.READ,
        readAt: new Date()
      }
    );

    return { modifiedCount: result.modifiedCount };
  }

  async getUnreadCount(userId?: string): Promise<number> {
    const filter: any = { 
      isDeleted: false,
      status: NotificationStatus.UNREAD
    };

    if (userId) {
      filter.userId = new Types.ObjectId(userId);
    }

    return this.notificationModel.countDocuments(filter);
  }

  async findByType(type: NotificationType, userId?: string): Promise<Notification[]> {
    const filter: any = { 
      type,
      isDeleted: false
    };

    if (userId) {
      filter.userId = new Types.ObjectId(userId);
    }

    return this.notificationModel
      .find(filter)
      .sort({ createdAt: -1 })
      .populate('userId', 'username fullname')
      .exec();
  }

  async findByPriority(priority: NotificationPriority, userId?: string): Promise<Notification[]> {
    const filter: any = { 
      priority,
      isDeleted: false
    };

    if (userId) {
      filter.userId = new Types.ObjectId(userId);
    }

    return this.notificationModel
      .find(filter)
      .sort({ createdAt: -1 })
      .populate('userId', 'username fullname')
      .exec();
  }

  async getSystemNotifications(): Promise<Notification[]> {
    return this.notificationModel
      .find({ 
        type: NotificationType.SYSTEM,
        isDeleted: false
      })
      .sort({ createdAt: -1 })
      .populate('userId', 'username fullname')
      .exec();
  }

  async getAutoGeneratedNotifications(): Promise<Notification[]> {
    return this.notificationModel
      .find({ 
        isAutoGenerated: true,
        isDeleted: false
      })
      .sort({ createdAt: -1 })
      .populate('userId', 'username fullname')
      .exec();
  }

  // Tạo thông báo tự động cho các sự kiện hệ thống
  async createAutoNotification(
    title: string,
    message: string,
    type: NotificationType,
    priority: NotificationPriority = NotificationPriority.MEDIUM,
    userId?: string,
    relatedEntityId?: string,
    relatedEntityType?: string,
    metadata?: any
  ): Promise<Notification> {
    return this.create({
      title,
      message,
      type,
      priority,
      userId,
      relatedEntityId,
      relatedEntityType,
      metadata,
      isAutoGenerated: true
    });
  }

  // Tạo thông báo broadcast (gửi cho tất cả user)
  async createBroadcastNotification(
    title: string,
    message: string,
    priority: NotificationPriority = NotificationPriority.MEDIUM,
    metadata?: any
  ): Promise<Notification> {
    return this.create({
      title,
      message,
      type: NotificationType.SYSTEM,
      priority,
      metadata,
      isAutoGenerated: false
    });
  }

  // Xóa thông báo hết hạn
  async deleteExpiredNotifications(): Promise<{ deletedCount: number }> {
    const result = await this.notificationModel.updateMany(
      { 
        expiresAt: { $lt: new Date() },
        isDeleted: false
      },
      { isDeleted: true }
    );

    return { deletedCount: result.modifiedCount };
  }
}
