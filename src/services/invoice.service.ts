import { Injectable, Logger, NotFoundException, BadRequestException, ForbiddenException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { Invoice } from '../models/invoice.model';
import { Material } from '../models/material.model';
import { CreateInvoiceDto, UpdateInvoiceDto, UpdateInvoiceStatusDto, UpdatePaymentStatusDto, InvoiceQueryDto, CreateInvoiceItemDto, PaymentDto } from '../dto/invoice.dto';
import { PaymentMethod } from '../constants/payment.constants';

@Injectable()
export class InvoiceService {
  private readonly logger = new Logger(InvoiceService.name);

  constructor(
    @InjectModel(Invoice.name) private invoiceModel: Model<Invoice>,
    @InjectModel(Material.name) private materialModel: Model<Material>,
  ) {}

  // T·∫°o s·ªë ho√° ƒë∆°n t·ª± ƒë·ªông
  private async generateInvoiceNumber(): Promise<string> {
    const today = new Date();
    const year = today.getFullYear();
    const month = String(today.getMonth() + 1).padStart(2, '0');
    const day = String(today.getDate()).padStart(2, '0');
    
    const prefix = `HD${year}${month}${day}`;
    
    // T√¨m s·ªë ho√° ƒë∆°n cu·ªëi c√πng trong ng√†y
    const lastInvoice = await this.invoiceModel
      .findOne({
        invoiceNumber: { $regex: `^${prefix}` },
        isDeleted: false
      })
      .sort({ invoiceNumber: -1 })
      .exec();

    if (!lastInvoice) {
      return `${prefix}001`;
    }

    const lastNumber = parseInt(lastInvoice.invoiceNumber.slice(-3));
    const newNumber = lastNumber + 1;
    return `${prefix}${String(newNumber).padStart(3, '0')}`;
  }

  // T√≠nh to√°n gi√° tr·ªã ho√° ƒë∆°n
  private calculateInvoiceValues(items: any[], taxRate: number = 0, discountRate: number = 0) {
    const subtotal = items.reduce((sum, item) => sum + (item.quantity * item.unitPrice), 0);
    const taxAmount = (subtotal * taxRate) / 100;
    const discountAmount = (subtotal * discountRate) / 100;
    const totalAmount = subtotal + taxAmount - discountAmount;

    return {
      subtotal,
      taxAmount,
      discountAmount,
      totalAmount
    };
  }

  // Ki·ªÉm tra t·ªìn kho tr∆∞·ªõc khi th·ª±c hi·ªán thao t√°c
  private async checkInventoryAvailability(items: any[], userId: string): Promise<void> {
    this.logger.log(`üîç Ki·ªÉm tra t·ªìn kho cho ${items.length} v·∫≠t li·ªáu`);
    
    for (const item of items) {
      const material = await this.materialModel.findById(item.materialId);
      if (!material) {
        throw new NotFoundException(`V·∫≠t li·ªáu v·ªõi ID ${item.materialId} kh√¥ng t·ªìn t·∫°i`);
      }

      // Ki·ªÉm tra quy·ªÅn s·ªü h·ªØu v·∫≠t li·ªáu
      if (material.userId.toString() !== userId) {
        throw new ForbiddenException(`B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng v·∫≠t li·ªáu ${material.name}`);
      }

      // Ki·ªÉm tra t·ªìn kho
      if (material.quantity < item.quantity) {
        throw new BadRequestException(
          `Kh√¥ng ƒë·ªß t·ªìn kho cho v·∫≠t li·ªáu "${material.name}". T·ªìn kho hi·ªán t·∫°i: ${material.quantity}, y√™u c·∫ßu: ${item.quantity}`
        );
      }

      this.logger.log(`‚úÖ V·∫≠t li·ªáu ${material.name}: T·ªìn kho ${material.quantity} >= Y√™u c·∫ßu ${item.quantity}`);
    }
  }

  // C·∫≠p nh·∫≠t t·ªìn kho v·∫≠t li·ªáu
  private async updateMaterialInventory(items: any[], operation: 'increase' | 'decrease'): Promise<void> {
    this.logger.log(`üîÑ C·∫≠p nh·∫≠t t·ªìn kho v·∫≠t li·ªáu - Thao t√°c: ${operation}`);
    
    for (const item of items) {
      const material = await this.materialModel.findById(item.materialId);
      if (!material) {
        this.logger.warn(`‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y v·∫≠t li·ªáu v·ªõi ID: ${item.materialId}`);
        continue;
      }

      const quantityChange = operation === 'increase' ? item.quantity : -item.quantity;
      const newQuantity = material.quantity + quantityChange;

      // ƒê·∫£m b·∫£o s·ªë l∆∞·ª£ng kh√¥ng √¢m
      if (newQuantity < 0) {
        this.logger.warn(`‚ö†Ô∏è S·ªë l∆∞·ª£ng t·ªìn kho kh√¥ng th·ªÉ √¢m cho v·∫≠t li·ªáu ${material.name}. B·ªè qua c·∫≠p nh·∫≠t.`);
        continue;
      }

      await this.materialModel.findByIdAndUpdate(
        item.materialId,
        { quantity: newQuantity },
        { new: true }
      );

      this.logger.log(
        `üì¶ C·∫≠p nh·∫≠t t·ªìn kho ${material.name}: ${material.quantity} ‚Üí ${newQuantity} (${operation} ${item.quantity})`
      );
    }
  }

  // T·∫°o ho√° ƒë∆°n m·ªõi
  async create(createInvoiceDto: CreateInvoiceDto, userId: string): Promise<Invoice> {
    this.logger.log(`T·∫°o ho√° ƒë∆°n m·ªõi cho kh√°ch h√†ng: ${createInvoiceDto.customerName}`);

    // Validation cho ph∆∞∆°ng th·ª©c thanh to√°n
    if (createInvoiceDto.paymentMethod === PaymentMethod.DEBT) {
      this.logger.log('Ho√° ƒë∆°n ƒë∆∞·ª£c t·∫°o v·ªõi ph∆∞∆°ng th·ª©c thanh to√°n: N·ª£');
      // C√≥ th·ªÉ th√™m validation ƒë·∫∑c bi·ªát cho ho√° ƒë∆°n n·ª£ ·ªü ƒë√¢y
      // V√≠ d·ª•: ki·ªÉm tra h·∫°n m·ª©c n·ª£ c·ªßa kh√°ch h√†ng
      
      // T·ª± ƒë·ªông set paymentStatus th√†nh 'unpaid' cho ho√° ƒë∆°n n·ª£
      createInvoiceDto.paymentStatus = 'unpaid';
    } else if (createInvoiceDto.paymentMethod === PaymentMethod.CASH) {
      this.logger.log('Ho√° ƒë∆°n ƒë∆∞·ª£c t·∫°o v·ªõi ph∆∞∆°ng th·ª©c thanh to√°n: Ti·ªÅn m·∫∑t');
      // C√≥ th·ªÉ th√™m validation ƒë·∫∑c bi·ªát cho ho√° ƒë∆°n ti·ªÅn m·∫∑t
      
      // N·∫øu kh√¥ng c√≥ paymentStatus, m·∫∑c ƒë·ªãnh l√† 'paid' cho ti·ªÅn m·∫∑t
      if (!createInvoiceDto.paymentStatus) {
        createInvoiceDto.paymentStatus = 'paid';
      }
    } else if (createInvoiceDto.paymentMethod === PaymentMethod.ONLINE) {
      this.logger.log('Ho√° ƒë∆°n ƒë∆∞·ª£c t·∫°o v·ªõi ph∆∞∆°ng th·ª©c thanh to√°n: Online');
      // C√≥ th·ªÉ th√™m validation ƒë·∫∑c bi·ªát cho ho√° ƒë∆°n online
      
      // N·∫øu kh√¥ng c√≥ paymentStatus, m·∫∑c ƒë·ªãnh l√† 'unpaid' cho online (ch·ªù x√°c nh·∫≠n)
      if (!createInvoiceDto.paymentStatus) {
        createInvoiceDto.paymentStatus = 'unpaid';
      }
    }

    // Ki·ªÉm tra t·ªìn kho tr∆∞·ªõc khi t·∫°o ho√° ƒë∆°n
    await this.checkInventoryAvailability(createInvoiceDto.items, userId);

    // C·∫≠p nh·∫≠t th√¥ng tin v·∫≠t li·ªáu
    const updatedItems = await Promise.all(
      createInvoiceDto.items.map(async (item: CreateInvoiceItemDto) => {
        const material = await this.materialModel.findById(item.materialId);
        if (!material) {
          throw new NotFoundException(`V·∫≠t li·ªáu v·ªõi ID ${item.materialId} kh√¥ng t·ªìn t·∫°i`);
        }

        // T·ª± ƒë·ªông l·∫•y th√¥ng tin v·∫≠t li·ªáu t·ª´ database
        return {
          materialId: item.materialId,
          materialName: material.name,
          quantity: item.quantity,
          unitPrice: material.price || 0, // L·∫•y gi√° t·ª´ database
          unit: material.unit || 'c√°i', // L·∫•y ƒë∆°n v·ªã t·ª´ database
          totalPrice: item.quantity * (material.price || 0)
        };
      })
    );

    // T√≠nh to√°n gi√° tr·ªã ho√° ƒë∆°n
    const values = this.calculateInvoiceValues(
      updatedItems,
      createInvoiceDto.taxRate || 0,
      createInvoiceDto.discountRate || 0
    );

    // T·∫°o s·ªë ho√° ƒë∆°n
    const invoiceNumber = await this.generateInvoiceNumber();

    // X·ª≠ l√Ω paidAmount d·ª±a tr√™n paymentStatus
    let paidAmount = 0;
    if (createInvoiceDto.paymentStatus === 'paid') {
      paidAmount = values.totalAmount;
    } else if (createInvoiceDto.paymentStatus === 'partial' && createInvoiceDto.paidAmount) {
      paidAmount = createInvoiceDto.paidAmount;
    }

    // T√≠nh remainingAmount
    const remainingAmount = values.totalAmount - paidAmount;

    // Debug logging cho vi·ªác t·∫°o ho√° ƒë∆°n
    this.logger.log(`üîç Debug t·∫°o ho√° ƒë∆°n:`);
    this.logger.log(`  - totalAmount: ${values.totalAmount}`);
    this.logger.log(`  - paidAmount: ${paidAmount}`);
    this.logger.log(`  - remainingAmount: ${remainingAmount}`);
    this.logger.log(`  - paymentStatus: ${createInvoiceDto.paymentStatus}`);

    const invoice = new this.invoiceModel({
      ...createInvoiceDto,
      invoiceNumber,
      items: updatedItems,
      ...values,
      paidAmount,
      remainingAmount,
      createdBy: new Types.ObjectId(userId),
      customerId: new Types.ObjectId(userId), // T·∫°m th·ªùi g√°n cho user hi·ªán t·∫°i
    });

    const savedInvoice = await invoice.save();
    
    // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng t·ªìn kho sau khi t·∫°o ho√° ƒë∆°n th√†nh c√¥ng
    await this.updateMaterialInventory(updatedItems, 'decrease');
    
    this.logger.log(`Ho√° ƒë∆°n ${invoiceNumber} ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng`);
    
    return savedInvoice;
  }

  // L·∫•y danh s√°ch ho√° ƒë∆°n v·ªõi ph√¢n trang v√† filter
  async findAll(query: InvoiceQueryDto, userId: string): Promise<{ invoices: Invoice[]; total: number; page: number; limit: number }> {
    this.logger.log(`L·∫•y danh s√°ch ho√° ƒë∆°n cho user: ${userId}`);

    const {
      status,
      paymentStatus,
      paymentMethod,
      customerName,
      invoiceNumber,
      startDate,
      endDate,
      page = 1,
      limit = 10
    } = query;

    const filter: any = { 
      isDeleted: false,
      createdBy: new Types.ObjectId(userId) // Ch·ªâ l·∫•y ho√° ƒë∆°n c·ªßa user hi·ªán t·∫°i
    };

    if (status) filter.status = status;
    if (paymentStatus) filter.paymentStatus = paymentStatus;
    if (paymentMethod) filter.paymentMethod = paymentMethod;
    if (customerName) filter.customerName = { $regex: customerName, $options: 'i' };
    if (invoiceNumber) filter.invoiceNumber = { $regex: invoiceNumber, $options: 'i' };
    
    if (startDate || endDate) {
      filter.createdAt = {};
      if (startDate) filter.createdAt.$gte = new Date(startDate);
      if (endDate) filter.createdAt.$lte = new Date(endDate);
    }

    const skip = (page - 1) * limit;

    const [invoices, total] = await Promise.all([
      this.invoiceModel
        .find(filter)
        .populate('customerId', 'name email')
        .populate('createdBy', 'name email')
        .populate('approvedBy', 'name email')
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit)
        .exec(),
      this.invoiceModel.countDocuments(filter)
    ]);

    return {
      invoices,
      total,
      page,
      limit
    };
  }

  // L·∫•y ho√° ƒë∆°n theo ID
  async findOne(id: string, userId: string): Promise<Invoice> {
    this.logger.log(`L·∫•y ho√° ƒë∆°n v·ªõi ID: ${id} cho user: ${userId}`);

    const invoice = await this.invoiceModel
      .findOne({ _id: id, isDeleted: false, createdBy: new Types.ObjectId(userId) })
      .populate('customerId', 'name email')
      .populate('createdBy', 'name email')
      .populate('approvedBy', 'name email')
      .exec();

    if (!invoice) {
      throw new NotFoundException(`Ho√° ƒë∆°n v·ªõi ID ${id} kh√¥ng t·ªìn t·∫°i ho·∫∑c b·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p`);
    }

    return invoice;
  }

  // L·∫•y ho√° ƒë∆°n theo s·ªë ho√° ƒë∆°n
  async findByInvoiceNumber(invoiceNumber: string, userId: string): Promise<Invoice> {
    this.logger.log(`L·∫•y ho√° ƒë∆°n v·ªõi s·ªë: ${invoiceNumber} cho user: ${userId}`);

    const invoice = await this.invoiceModel
      .findOne({ 
        invoiceNumber, 
        isDeleted: false, 
        createdBy: new Types.ObjectId(userId) 
      })
      .populate('customerId', 'name email')
      .populate('createdBy', 'name email')
      .populate('approvedBy', 'name email')
      .exec();

    if (!invoice) {
      throw new NotFoundException(`Ho√° ƒë∆°n v·ªõi s·ªë ${invoiceNumber} kh√¥ng t·ªìn t·∫°i ho·∫∑c b·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p`);
    }

    return invoice;
  }

  // C·∫≠p nh·∫≠t ho√° ƒë∆°n
  async update(id: string, updateInvoiceDto: UpdateInvoiceDto, userId: string): Promise<Invoice> {
    this.logger.log(`C·∫≠p nh·∫≠t ho√° ƒë∆°n v·ªõi ID: ${id} cho user: ${userId}`);

    // Ki·ªÉm tra quy·ªÅn s·ªü h·ªØu
    const invoice = await this.invoiceModel
      .findOne({ _id: id, isDeleted: false, createdBy: new Types.ObjectId(userId) })
      .exec();

    if (!invoice) {
      throw new ForbiddenException('B·∫°n kh√¥ng c√≥ quy·ªÅn c·∫≠p nh·∫≠t ho√° ƒë∆°n n√†y');
    }

    // N·∫øu c·∫≠p nh·∫≠t items, t√≠nh to√°n l·∫°i gi√° tr·ªã
    let updatedItems: any[] = [];
    if (updateInvoiceDto.items) {
      // Kh√¥i ph·ª•c t·ªìn kho t·ª´ items c≈© tr∆∞·ªõc khi ki·ªÉm tra items m·ªõi
      await this.updateMaterialInventory(invoice.items, 'increase');
      
      // Ki·ªÉm tra t·ªìn kho cho items m·ªõi
      await this.checkInventoryAvailability(updateInvoiceDto.items, userId);
      
      updatedItems = await Promise.all(
        updateInvoiceDto.items.map(async (item) => {
          const material = await this.materialModel.findById(item.materialId);
          if (!material) {
            throw new NotFoundException(`V·∫≠t li·ªáu v·ªõi ID ${item.materialId} kh√¥ng t·ªìn t·∫°i`);
          }

          // T·ª± ƒë·ªông l·∫•y th√¥ng tin v·∫≠t li·ªáu t·ª´ database
          return {
            materialId: item.materialId,
            materialName: material.name,
            quantity: item.quantity,
            unitPrice: material.price || 0, // L·∫•y gi√° t·ª´ database
            unit: material.unit || 'c√°i', // L·∫•y ƒë∆°n v·ªã t·ª´ database
            totalPrice: item.quantity * (material.price || 0)
          };
        })
      );

      const values = this.calculateInvoiceValues(
        updatedItems,
        updateInvoiceDto.taxRate || invoice.taxRate,
        updateInvoiceDto.discountRate || invoice.discountRate
      );

      // T√≠nh l·∫°i remainingAmount n·∫øu c√≥ thay ƒë·ªïi v·ªÅ totalAmount
      const newRemainingAmount = values.totalAmount - (updateInvoiceDto.paidAmount || invoice.paidAmount);
      
      updateInvoiceDto = {
        ...updateInvoiceDto,
        items: updatedItems,
        ...values,
        remainingAmount: newRemainingAmount
      };
    }

    const updatedInvoice = await this.invoiceModel
      .findByIdAndUpdate(id, updateInvoiceDto, { new: true })
      .populate('customerId', 'name email')
      .populate('createdBy', 'name email')
      .populate('approvedBy', 'name email')
      .exec();

    if (!updatedInvoice) {
      throw new NotFoundException(`Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t ho√° ƒë∆°n v·ªõi ID ${id}`);
    }

    // C·∫≠p nh·∫≠t t·ªìn kho v·ªõi items m·ªõi n·∫øu c√≥ thay ƒë·ªïi
    if (updateInvoiceDto.items && updatedItems.length > 0) {
      await this.updateMaterialInventory(updatedItems, 'decrease');
    }

    this.logger.log(`Ho√° ƒë∆°n ${id} ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh c√¥ng cho user: ${userId}`);
    return updatedInvoice;
  }

  // C·∫≠p nh·∫≠t tr·∫°ng th√°i ho√° ƒë∆°n
  async updateStatus(id: string, updateStatusDto: UpdateInvoiceStatusDto, userId: string): Promise<Invoice> {
    this.logger.log(`C·∫≠p nh·∫≠t tr·∫°ng th√°i ho√° ƒë∆°n ${id} th√†nh: ${updateStatusDto.status} cho user: ${userId}`);

    // Ki·ªÉm tra quy·ªÅn s·ªü h·ªØu
    const invoice = await this.invoiceModel
      .findOne({ _id: id, isDeleted: false, createdBy: new Types.ObjectId(userId) })
      .exec();

    if (!invoice) {
      throw new ForbiddenException('B·∫°n kh√¥ng c√≥ quy·ªÅn c·∫≠p nh·∫≠t ho√° ƒë∆°n n√†y');
    }

    // Ki·ªÉm tra quy·ªÅn c·∫≠p nh·∫≠t tr·∫°ng th√°i
    if (invoice.status === 'delivered' || invoice.status === 'cancelled') {
      throw new BadRequestException('Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i ho√° ƒë∆°n ƒë√£ ho√†n th√†nh ho·∫∑c b·ªã h·ªßy');
    }

    const updateData: any = {
      status: updateStatusDto.status,
      notes: updateStatusDto.notes
    };

    // N·∫øu x√°c nh·∫≠n ho√° ƒë∆°n, ghi nh·∫≠n ng∆∞·ªùi duy·ªát
    if (updateStatusDto.status === 'confirmed') {
      updateData.approvedBy = new Types.ObjectId(userId);
      updateData.approvedAt = new Date();
    }

    // N·∫øu h·ªßy ho√° ƒë∆°n, tr·∫£ h√†ng v·ªÅ kho
    if (updateStatusDto.status === 'cancelled') {
      this.logger.log(`üîÑ H·ªßy ho√° ƒë∆°n ${id} - Tr·∫£ h√†ng v·ªÅ kho`);
      await this.updateMaterialInventory(invoice.items, 'increase');
      this.logger.log(`‚úÖ ƒê√£ tr·∫£ ${invoice.items.length} lo·∫°i v·∫≠t li·ªáu v·ªÅ kho khi h·ªßy ho√° ƒë∆°n ${id}`);
    }

    const updatedInvoice = await this.invoiceModel
      .findByIdAndUpdate(id, updateData, { new: true })
      .populate('customerId', 'name email')
      .populate('createdBy', 'name email')
      .populate('approvedBy', 'name email')
      .exec();

    if (!updatedInvoice) {
      throw new NotFoundException(`Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i ho√° ƒë∆°n v·ªõi ID ${id}`);
    }

    this.logger.log(`Tr·∫°ng th√°i ho√° ƒë∆°n ${id} ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh: ${updateStatusDto.status} cho user: ${userId}`);
    return updatedInvoice;
  }

  // Thanh to√°n cho ho√° ƒë∆°n
  async makePayment(id: string, paymentDto: PaymentDto, userId: string): Promise<Invoice> {
    this.logger.log(`üí≥ Thanh to√°n ${paymentDto.amount} cho ho√° ƒë∆°n ${id} b·ªüi user: ${userId}`);

    // Ki·ªÉm tra quy·ªÅn s·ªü h·ªØu
    const invoice = await this.invoiceModel
      .findOne({ _id: id, isDeleted: false, createdBy: new Types.ObjectId(userId) })
      .exec();

    if (!invoice) {
      throw new ForbiddenException('B·∫°n kh√¥ng c√≥ quy·ªÅn thanh to√°n ho√° ƒë∆°n n√†y');
    }

    // Validation
    if (paymentDto.amount <= 0) {
      throw new BadRequestException('S·ªë ti·ªÅn thanh to√°n ph·∫£i l·ªõn h∆°n 0');
    }

    // Debug logging
    this.logger.log(`üîç Debug thanh to√°n - Ho√° ƒë∆°n ${id}:`);
    this.logger.log(`  - totalAmount: ${invoice.totalAmount}`);
    this.logger.log(`  - paidAmount: ${invoice.paidAmount}`);
    this.logger.log(`  - remainingAmount: ${invoice.remainingAmount}`);
    this.logger.log(`  - paymentDto.amount: ${paymentDto.amount}`);

    // Ki·ªÉm tra remainingAmount c√≥ h·ª£p l·ªá kh√¥ng
    if (invoice.remainingAmount <= 0) {
      throw new BadRequestException('Ho√° ƒë∆°n ƒë√£ ƒë∆∞·ª£c thanh to√°n ƒë·∫ßy ƒë·ªß, kh√¥ng th·ªÉ thanh to√°n th√™m');
    }

    if (paymentDto.amount > invoice.remainingAmount) {
      throw new BadRequestException(`S·ªë ti·ªÅn thanh to√°n (${paymentDto.amount}) kh√¥ng th·ªÉ v∆∞·ª£t qu√° s·ªë ti·ªÅn c√≤n l·∫°i (${invoice.remainingAmount})`);
    }

    // T√≠nh to√°n s·ªë ti·ªÅn m·ªõi
    const newPaidAmount = invoice.paidAmount + paymentDto.amount;
    const newRemainingAmount = invoice.totalAmount - newPaidAmount;

    // X√°c ƒë·ªãnh tr·∫°ng th√°i thanh to√°n m·ªõi
    let newPaymentStatus: 'unpaid' | 'partial' | 'paid';
    if (newRemainingAmount === 0) {
      newPaymentStatus = 'paid';
    } else if (newPaidAmount > 0) {
      newPaymentStatus = 'partial';
    } else {
      newPaymentStatus = 'unpaid';
    }

    // C·∫≠p nh·∫≠t ho√° ƒë∆°n
    const updateData: any = {
      paidAmount: newPaidAmount,
      remainingAmount: newRemainingAmount,
      paymentStatus: newPaymentStatus,
      notes: paymentDto.notes || invoice.notes
    };

    // C·∫≠p nh·∫≠t ph∆∞∆°ng th·ª©c thanh to√°n n·∫øu ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh
    if (paymentDto.paymentMethod) {
      updateData.paymentMethod = paymentDto.paymentMethod;
    }

    const updatedInvoice = await this.invoiceModel
      .findByIdAndUpdate(id, updateData, { new: true })
      .populate('customerId', 'name email')
      .populate('createdBy', 'name email')
      .populate('approvedBy', 'name email')
      .exec();

    if (!updatedInvoice) {
      throw new NotFoundException(`Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t thanh to√°n cho ho√° ƒë∆°n v·ªõi ID ${id}`);
    }

    this.logger.log(`‚úÖ Thanh to√°n th√†nh c√¥ng: ${paymentDto.amount} cho ho√° ƒë∆°n ${id}. S·ªë ti·ªÅn c√≤n l·∫°i: ${newRemainingAmount}`);
    return updatedInvoice;
  }

  // C·∫≠p nh·∫≠t tr·∫°ng th√°i thanh to√°n
  async updatePaymentStatus(id: string, updatePaymentDto: UpdatePaymentStatusDto, userId: string): Promise<Invoice> {
    this.logger.log(`C·∫≠p nh·∫≠t tr·∫°ng th√°i thanh to√°n ho√° ƒë∆°n ${id} th√†nh: ${updatePaymentDto.paymentStatus} cho user: ${userId}`);

    // Ki·ªÉm tra quy·ªÅn s·ªü h·ªØu
    const invoice = await this.invoiceModel
      .findOne({ _id: id, isDeleted: false, createdBy: new Types.ObjectId(userId) })
      .exec();

    if (!invoice) {
      throw new ForbiddenException('B·∫°n kh√¥ng c√≥ quy·ªÅn c·∫≠p nh·∫≠t ho√° ƒë∆°n n√†y');
    }

    // Validation cho paidAmount
    if (updatePaymentDto.paidAmount !== undefined) {
      if (updatePaymentDto.paidAmount < 0) {
        throw new BadRequestException('S·ªë ti·ªÅn ƒë√£ tr·∫£ kh√¥ng th·ªÉ √¢m');
      }
      if (updatePaymentDto.paidAmount > invoice.totalAmount) {
        throw new BadRequestException('S·ªë ti·ªÅn ƒë√£ tr·∫£ kh√¥ng th·ªÉ v∆∞·ª£t qu√° t·ªïng ti·ªÅn ho√° ƒë∆°n');
      }
    }

    // Validation cho remainingAmount
    if (updatePaymentDto.remainingAmount !== undefined) {
      if (updatePaymentDto.remainingAmount < 0) {
        throw new BadRequestException('S·ªë ti·ªÅn c√≤n l·∫°i kh√¥ng th·ªÉ √¢m');
      }
      if (updatePaymentDto.remainingAmount > invoice.totalAmount) {
        throw new BadRequestException('S·ªë ti·ªÅn c√≤n l·∫°i kh√¥ng th·ªÉ v∆∞·ª£t qu√° t·ªïng ti·ªÅn ho√° ƒë∆°n');
      }
    }

    const updateData: any = {
      paymentStatus: updatePaymentDto.paymentStatus,
      notes: updatePaymentDto.notes
    };

    // C·∫≠p nh·∫≠t paidAmount n·∫øu c√≥
    if (updatePaymentDto.paidAmount !== undefined) {
      updateData.paidAmount = updatePaymentDto.paidAmount;
      // T·ª± ƒë·ªông t√≠nh remainingAmount
      updateData.remainingAmount = invoice.totalAmount - updatePaymentDto.paidAmount;
    }

    // T·ª± ƒë·ªông c·∫≠p nh·∫≠t paymentStatus d·ª±a tr√™n paidAmount n·∫øu kh√¥ng ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh
    if (updatePaymentDto.paymentStatus === undefined && updatePaymentDto.paidAmount !== undefined) {
      if (updatePaymentDto.paidAmount === 0) {
        updateData.paymentStatus = 'unpaid';
      } else if (updatePaymentDto.paidAmount >= invoice.totalAmount) {
        updateData.paymentStatus = 'paid';
      } else {
        updateData.paymentStatus = 'partial';
      }
    }

    // N·∫øu ch·ªâ c·∫≠p nh·∫≠t remainingAmount m√† kh√¥ng c√≥ paidAmount, t√≠nh ng∆∞·ª£c l·∫°i
    if (updatePaymentDto.remainingAmount !== undefined && updatePaymentDto.paidAmount === undefined) {
      updateData.paidAmount = invoice.totalAmount - updatePaymentDto.remainingAmount;
      updateData.remainingAmount = updatePaymentDto.remainingAmount;
      
      // T·ª± ƒë·ªông c·∫≠p nh·∫≠t paymentStatus d·ª±a tr√™n paidAmount m·ªõi
      if (updateData.paidAmount === 0) {
        updateData.paymentStatus = 'unpaid';
      } else if (updateData.paidAmount >= invoice.totalAmount) {
        updateData.paymentStatus = 'paid';
      } else {
        updateData.paymentStatus = 'partial';
      }
    }

    const updatedInvoice = await this.invoiceModel
      .findByIdAndUpdate(id, updateData, { new: true })
      .populate('customerId', 'name email')
      .populate('createdBy', 'name email')
      .populate('approvedBy', 'name email')
      .exec();

    if (!updatedInvoice) {
      throw new NotFoundException(`Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i thanh to√°n ho√° ƒë∆°n v·ªõi ID ${id}`);
    }

    this.logger.log(`Tr·∫°ng th√°i thanh to√°n ho√° ƒë∆°n ${id} ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh: ${updatePaymentDto.paymentStatus} cho user: ${userId}`);
    return updatedInvoice;
  }

  // X√≥a m·ªÅm ho√° ƒë∆°n
  async remove(id: string, userId: string): Promise<void> {
    this.logger.log(`X√≥a ho√° ƒë∆°n v·ªõi ID: ${id} cho user: ${userId}`);

    // Ki·ªÉm tra quy·ªÅn s·ªü h·ªØu
    const invoice = await this.invoiceModel
      .findOne({ _id: id, isDeleted: false, createdBy: new Types.ObjectId(userId) })
      .exec();

    if (!invoice) {
      throw new ForbiddenException('B·∫°n kh√¥ng c√≥ quy·ªÅn x√≥a ho√° ƒë∆°n n√†y');
    }

    // Ki·ªÉm tra quy·ªÅn x√≥a
    if (invoice.status === 'delivered' || invoice.paymentStatus === 'paid') {
      throw new BadRequestException('Kh√¥ng th·ªÉ x√≥a ho√° ƒë∆°n ƒë√£ ho√†n th√†nh ho·∫∑c ƒë√£ thanh to√°n');
    }

    // Kh√¥i ph·ª•c t·ªìn kho khi x√≥a ho√° ƒë∆°n
    await this.updateMaterialInventory(invoice.items, 'increase');

    await this.invoiceModel.findByIdAndUpdate(id, { isDeleted: true });
    this.logger.log(`Ho√° ƒë∆°n ${id} ƒë√£ ƒë∆∞·ª£c x√≥a th√†nh c√¥ng cho user: ${userId}`);
  }

  // Th·ªëng k√™ ho√° ƒë∆°n
  async getStatistics(userId: string, startDate?: string, endDate?: string) {
    this.logger.log(`L·∫•y th·ªëng k√™ ho√° ƒë∆°n cho user: ${userId}`);

    const filter: any = { 
      isDeleted: false,
      createdBy: new Types.ObjectId(userId) // Ch·ªâ l·∫•y th·ªëng k√™ c·ªßa user hi·ªán t·∫°i
    };
    
    if (startDate || endDate) {
      filter.createdAt = {};
      if (startDate) filter.createdAt.$gte = new Date(startDate);
      if (endDate) filter.createdAt.$lte = new Date(endDate);
    }

    const [
      totalInvoices,
      totalRevenue,
      pendingInvoices,
      confirmedInvoices,
      deliveredInvoices,
      cancelledInvoices,
      unpaidInvoices,
      paidInvoices,
      paymentMethodStats
    ] = await Promise.all([
      this.invoiceModel.countDocuments(filter),
      this.invoiceModel.aggregate([
        { $match: filter },
        { $group: { _id: null, total: { $sum: '$totalAmount' } } }
      ]),
      this.invoiceModel.countDocuments({ ...filter, status: 'pending' }),
      this.invoiceModel.countDocuments({ ...filter, status: 'confirmed' }),
      this.invoiceModel.countDocuments({ ...filter, status: 'delivered' }),
      this.invoiceModel.countDocuments({ ...filter, status: 'cancelled' }),
      this.invoiceModel.countDocuments({ ...filter, paymentStatus: 'unpaid' }),
      this.invoiceModel.countDocuments({ ...filter, paymentStatus: 'paid' }),
      this.invoiceModel.aggregate([
        { $match: filter },
        { $group: { _id: '$paymentMethod', count: { $sum: 1 }, totalAmount: { $sum: '$totalAmount' } } }
      ])
    ]);

    // X·ª≠ l√Ω th·ªëng k√™ theo ph∆∞∆°ng th·ª©c thanh to√°n
    const paymentMethods = {};
    paymentMethodStats.forEach(stat => {
      paymentMethods[stat._id] = {
        count: stat.count,
        totalAmount: stat.totalAmount
      };
    });

    return {
      totalInvoices,
      totalRevenue: totalRevenue[0]?.total || 0,
      pendingInvoices,
      confirmedInvoices,
      deliveredInvoices,
      cancelledInvoices,
      unpaidInvoices,
      paidInvoices,
      paymentMethods
    };
  }
}
